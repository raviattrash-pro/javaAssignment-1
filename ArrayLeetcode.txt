Q1.
public int[] buildArray(int[] nums) {
	int mask = 1023; // Decimal value of the binary number '1111111111'
	for(int i = 0; i < nums.length; i++)
		nums[i] |= (nums[nums[i]] & mask) << 10;
	for(int i = 0; i < nums.length; i++)
		nums[i] = nums[i] >> 10;
	return nums;
}

_________________________________________________________________________________
Q2.

   int n = nums.length;
        int[] arr = new int[2*n];
        for(int i = 0; i < n; i++){
            arr[i] = nums[i];
            arr[i + n] = nums[i];
        }
        return arr;
______________________________________________________________________________________
Q3.

class Solution {
    public int[] runningSum(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            nums[i] += nums[i - 1];
        }
        return nums;
    }
}

_____________________________________________________________________________

Q4.

class Solution {
    public int maximumWealth(int[][] accounts) {
        int max = Integer.MIN_VALUE;
        int sum=0;
        for(int i=0;i<accounts.length;i++){
             sum=0;
            for(int j=0;j<accounts[0].length;j++){
                sum+=accounts[i][j];
            }

            if(sum>max){
                max=sum;
            }
        }
        return max;
    }
}

___________________________________________________________________________________
Q5

class Solution {
    public int[] shuffle(int[] nums, int n) {
        int[] result = new int[2 * n];
        for (int i = 0; i < n; ++i) {
            result[2 * i] = nums[i];
            result[2 * i + 1] = nums[n + i];
        }
        return result;
    }
}


 In-place Filling 

class Solution {
    public int[] shuffle(int[] nums, int n) {
        // Store each y(i) with respective x(i).
        for (int i = n; i < 2 * n; ++i) {
            int secondNum = nums[i] << 10;
            nums[i - n] |= secondNum;
        }

        // '0000000000 1111111111' in decimal.
        int allOnes = (int) Math.pow(2, 10) - 1;

        // We will start putting all numbers from the end, 
        // as they are empty places.
        for (int i = n - 1; i >= 0; --i) {
            // Fetch both the numbers from the current index.
            int secondNum = nums[i] >> 10;
            int firstNum = nums[i] & allOnes;
            nums[2 * i + 1] = secondNum;
            nums[2 * i] = firstNum;
        }
        return nums;
    }
}

Algorithm -> please check this ->https://leetcode.com/problems/shuffle-the-array/solutions/?orderBy=most_votes

Iterate on the nums array from index i = n to 2 * n - 1:
Store the element yi+1,that is, nums[i] with xi+1 
at index (i - n), using bit manipulation as discussed previously.

Iterate from index n - 1 to 0, and at each index i:
Extract both firstNumber and secondNumber using bit manipulation and store them at their respective indices 2 * i and 2 * i + 1 in the nums array.
Return the nums array.
_________________________________________________________________________________________________________________________________________________________________________

Q6

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        List<Boolean> list = new ArrayList<>();
        int max = Integer.MIN_VALUE;
        for(int i=0;i<candies.length;i++){ //max amoung array 
            if(candies[i]>max){
                max = candies[i];
            }
        }

        for(int i=0;i<candies.length;i++){ //putting boolean value 
            if(candies[i]+extraCandies>=max){
                list.add(true);
            }
            else{
                  list.add(false);
            }
        }
        return list;
    }
}
___________________________________________________________________________________
Q7

Imagine this problem like, There is a gathering organized by some guy, the guest list is [1,2,3,1,1,3].
The problem with the guest is they only handshake with like minded people. (Like minded here is basically the digit should be same , for example, 1 will handshake with 1 only, 2 will handshake with 2 only and so on)

So, finally we just need to count number of handshakes in the gathering. ðŸ’¯ ðŸ’¯

(To distinguish , multiple 1's and 3's , a,b,c,d... letters are used)

ðŸ”¥ the day of arrival ðŸ”¥

one by one guests are arriving at the gathering

âœ… first guest: 1

âœ… second guest: 2
(at this moment, in gathering hall we have 1 (2 is about to enter) , since they are not like minded they wont shake hands)

âœ… third guest:3
(at this moment, in gathering hall we have 1 ,2 (3 is about to enter), since they are not like minded they wont shake hands)

âœ… fourth guest : 1
(at this moment, fourth guest will see in gathering hall , there is one like minded guy ie(1) , so he will handshake with him)
therefore totalHandShake = 1

âœ… fifth guest : 1
(at this moment, fifth guest will see in gathering hall, there are two like minded guys ie(1,1) , so he will handshake with them)
therefore totalHandShake = 1(last handshake between 1a-1b ) + 2(current handshake between 1a-1c, 1b-1c) = 3

âœ… sixth guest : 3
(at this moment, sixth guest will see in gathering hall, there is one like minded guy ie(3) , so he will handshake with him)
therefore totalHandShake = 3(last handshake) + 1(3a-3b) = 4

Here, in code we can imagine


class Solution {
    public int numIdenticalPairs(int[] guestList) {
        HashMap<Integer, Integer> hm = new HashMap<>();
        
        int ans = 0;
        
        for(int friend:guestList)
        {
            int friendCount = hm.getOrDefault(friend,0);
            ans+=friendCount;
            hm.put(friend,friendCount+1);
        }
        
        
        return ans;
    }
}

___________________________________________________________________________________

Q8

public int[] smallerNumbersThanCurrent(int[] nums) {
        int[] buck = new int[101];
        
        for(int i=0; i<nums.length; i++) {
            buck[nums[i]] +=1;
        }
        
        for(int j=1; j<= 100; j++) {
            buck[j] += buck[j-1];
        }
        
        for(int k=0; k< nums.length; k++) {
            int pos = nums[k];
            nums[k] = pos==0 ? 0 : buck[pos-1];
        }
        
        return nums;
    }
	
For example, if nums array is
4 5 1 3 5 4 4 1 4 5 1 4

and the final bucket mapping is:
0 3 3 4 9 12
		